<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>Simulador Spitfire</title>
    <style>
        body { margin: 0; overflow: hidden; }
        /* HUD moderno com barras de progresso */
        #hud {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            
            color: rgb(2, 247, 43);
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 12px 14px;
            text-align: left;
            border-radius: 15px;
            backdrop-filter: blur(2px);
        }
        #hud .hud-heading { font-weight: 600; margin-bottom: 10px; text-align: center; }
        #hud .hud-item { display: flex; align-items: center; justify-content: space-between; margin: 18px 0; }
        #hud .hud-label { opacity: 0.9; width: 95px; }
        #hud .hud-bar { flex: 1; height: 10px; background: rgba(255,255,255,0.15); border-radius: 8px; overflow: hidden; }
        #hud .hud-fill { height: 100%; width: 0%; border-radius: 8px; box-shadow: 0 0 6px rgba(0,0,0,0.2); transition: width 0.12s ease-out; }
        #hud .hud-value { opacity: 0.9; font-weight: 600; }
        #hud #hud-fuel-fill { background: linear-gradient(90deg, #6f6, #1f1); box-shadow: 0 0 6px rgba(0,255,0,0.5); }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-top: -150px; /* Metade da altura */
            margin-left: -10px; /* Metade da largura */
            border: 1px solid white;
            border-radius: 50%;
            box-sizing: border-box;
            opacity: 0.2;
            pointer-events: none; /* Permite cliques através da mira */
            z-index: 1000; /* Garante que esteja acima de outros elementos */
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgb(124, 123, 123);
        }
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            margin-left: -1px;
        }
        #crosshair::after {
            top: 50%;
            left: 0;
            height: 2px;
            width: 100%;
            margin-top: -1px;
        }
        /* Overlay de Game Over */
        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* aparece após 1s da morte */
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
        }
        #game-over .text {
            color: #db0a0a;
            font-size: 64px;
            font-weight: 800;
            letter-spacing: 2px;
            text-shadow: 0 0 12px rgba(255,255,255,0.8);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }
        /* Modal de avanço de fase */
        #level-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding-top: 20px;
            background: rgba(0,0,0,0.2);
            z-index: 2000;
        }
        #level-modal .panel {
            background: rgba(20,20,20,0.92);
            padding: 24px 28px;
            border-radius: 14px;
            color: #fff;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.45);
        }
        #level-modal .panel h2 {
            margin: 0 0 12px 0;
            font-size: 22px;
        }
        #level-modal .panel p {
            margin: 0 0 16px 0;
            opacity: 0.85;
        }
        #level-modal .panel button {
            background: #2ecc71;
            border: none;
            color: #fff;
            font-size: 16px;
            padding: 10px 16px;
            border-radius: 10px;
            cursor: pointer;
        }
        #level-modal .panel button:hover {
            background: #27ae60;
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <div id="game-over"><div class="text">GAME OVER</div></div>
    <div id="level-modal">
        <div class="panel">
            <h2>Fase concluída</h2>
            <p>Pouso confirmado. Clique para iniciar a próxima fase.</p>
            <button id="start-next-level">Iniciar próxima fase</button>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { KTX2Loader } from 'https://unpkg.com/three@0.164.1/examples/jsm/loaders/KTX2Loader.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        const scene = new THREE.Scene();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Luz ambiente
        ambientLight.needsUpdate = false;
        scene.add(ambientLight);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0.9, 1.05); // Posição da câmera relativa ao avião (atrás e acima)
        camera.lookAt(0, 0, -15); // A câmera deve olhar para a frente do avião
        // Base para shake da câmera
        camera.userData.basePosition = camera.position.clone();
        camera.userData.baseRotation = camera.rotation.clone();
        camera.userData.shake = null;
       
        
        // scene.add(camera); // Removido: a câmera será adicionada como filho do avião

        const renderer = new THREE.WebGLRenderer({ antialias: true });

        const ktx2Loader = new KTX2Loader()
            .setTranscoderPath('https://unpkg.com/three@0.164.1/examples/jsm/libs/basis/')
            .detectSupport(renderer);

        const textureLoader = new THREE.TextureLoader();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        document.body.appendChild(renderer.domElement);

        // --- Minimap: cena, câmera, renderizador e container ---
        let minimapScene, minimapCamera, minimapRenderer, minimapAirplane;

        // Container do minimapa como overlay
        const minimapContainer = document.createElement('div');
        minimapContainer.style.position = 'absolute';
        minimapContainer.style.right = '10px';
        minimapContainer.style.bottom = '10px';
        minimapContainer.style.width = '200px';
        minimapContainer.style.height = '200px';
        minimapContainer.style.border = '2px solid white';
        minimapContainer.style.backgroundColor = 'rgba(128, 128, 128, 0.5)'; // Fundo cinza semi-transparente
        minimapContainer.style.zIndex = '1000';
        minimapContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.4)';
        document.body.appendChild(minimapContainer);

        minimapScene = new THREE.Scene();
        // minimapScene.background = new THREE.Color(0xffffff); // Removido para permitir fundo transparente via CSS

        minimapCamera = new THREE.OrthographicCamera(-1000, 1000, 1000, -1000, 1, 1000); // Aumentado para cobrir uma área maior
        minimapCamera.position.set(0, 250, 0);
        minimapCamera.rotation.x = -Math.PI / 2; // Vista de topo

        minimapRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Adicionado alpha: true
        minimapRenderer.setPixelRatio(window.devicePixelRatio);
        minimapRenderer.setSize(minimapContainer.clientWidth, minimapContainer.clientHeight);
        minimapContainer.appendChild(minimapRenderer.domElement);

        // Ponteiro fixo no centro do minimapa (overlay HTML)
        const minimapPointer = document.createElement('div');
        minimapPointer.id = 'minimap-pointer';
        minimapPointer.style.position = 'absolute';
        minimapPointer.style.top = '50%';
        minimapPointer.style.left = '50%';
        minimapPointer.style.transform = 'translate(-50%, -50%)';
        minimapPointer.style.width = '0';
        minimapPointer.style.height = '0';
        minimapPointer.style.borderLeft = '4px solid transparent';
        minimapPointer.style.borderRight = '4px solid transparent';
        minimapPointer.style.borderBottom = '8px solid red'; // Ponta para cima
        minimapPointer.style.zIndex = '1001';
        minimapPointer.style.pointerEvents = 'none';
        minimapContainer.appendChild(minimapPointer);

        // Representação simples da pista no minimapa
        const minimapRunwayGeom = new THREE.PlaneGeometry(10, 200);
        const minimapRunwayMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        const minimapRunway = new THREE.Mesh(minimapRunwayGeom, minimapRunwayMat);
        minimapRunway.rotation.x = -Math.PI / 2;
        minimapRunway.position.y = -3.98; // Mesma altura da pista principal
        minimapRunway.position.x = -40; // Mover a pista do minimapa 40 unidades para a esquerda
        minimapScene.add(minimapRunway);

        const centerLineGeom = new THREE.PlaneGeometry(0.5, 200);
        const centerLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const centerLine = new THREE.Mesh(centerLineGeom, centerLineMat);
        centerLine.rotation.x = -Math.PI / 2;
        centerLine.position.y = -3.97; // Acima da pista para evitar z-fighting
        centerLine.position.x = -40; // Mover a linha central do minimapa 40 unidades para a esquerda
        minimapScene.add(centerLine);

        // Iluminação com tom de fim de tarde
        const hemiLight = new THREE.HemisphereLight(0xffcc88, 0x1b1f3b, 0.7);
        scene.add(hemiLight);
        const sunLight = new THREE.DirectionalLight(0xffb347, 1.0);
        sunLight.position.set(-200, 100, -50);
        sunLight.castShadow = false;
        scene.add(sunLight);

        // Configuração do Sky
        const sky = new Sky();
        sky.scale.setScalar(450000); // Escala para cobrir a cena
        scene.add(sky);

        const sun = new THREE.Vector3();

        const phi = THREE.MathUtils.degToRad(90 - 0); // 0 graus para o sol no horizonte
        const theta = THREE.MathUtils.degToRad(180); // Posição do sol (leste/oeste)

        sun.setFromSphericalCoords(1, phi, theta);

        sky.material.uniforms['sunPosition'].value.copy(sun);
        scene.environment = pmremGenerator.fromScene(sky).texture;


            // Função para criar terreno com variação de altura e área plana para a pista
            let terrainMesh = null;
            function createTerrain() {
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100); // Terreno maior
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                // Evitar modificar a área da pista (ex: -50 a 50 no X, -100 a 100 no Z)
                if (Math.abs(x) > 1000 || Math.abs(z) > 1000) {
                    vertices[i + 1] = Math.sin(x / 80) * Math.cos(z / 80) * 1 + Math.random() * 0.5; // Variação de altura ajustada
                }
            }
            groundGeometry.computeVertexNormals();

            let groundMaterial;
            textureLoader.load('chao.jpg', (texture) => {
                groundMaterial = new THREE.MeshStandardMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
            const terrain = new THREE.Mesh(groundGeometry, groundMaterial);
            terrainMesh = terrain; // manter referência ao terreno para raycast
                terrain.rotation.x = -Math.PI / 2;
                terrain.position.y = -4;
                terrain.receiveShadow = true;
            scene.add(terrain);
            scene.add(createRunway());
                createClouds();
                createTrees();
            });
        }

        // Utilitário global: obter altura do terreno (y) em uma posição x/z via raycast
        function getGroundHeightAt(x, z) {
            // valor padrão do chão caso não haja interseção
            const defaultGroundY = -4;
            if (!terrainMesh) return defaultGroundY;
            const origin = new THREE.Vector3(x, 500, z);
            const dir = new THREE.Vector3(0, -1, 0);
            const ray = new THREE.Raycaster(origin, dir);
            const hits = ray.intersectObject(terrainMesh, true);
            return hits.length ? hits[0].point.y : defaultGroundY;
        }



function createClouds() {
    const cloudGroup = new THREE.Group();
    const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.1 });
    for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        const numParts = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < numParts; j++) {
            const size = 5 + Math.random() * 10;
            const geom = new THREE.SphereGeometry(size, 8, 8);
            const mesh = new THREE.Mesh(geom, cloudMaterial);
            mesh.position.set(Math.random() * 20 - 10, Math.random() * 5, Math.random() * 20 - 10);
            cloud.add(mesh);
        }
        cloud.position.set(Math.random() * 1000 - 500, 100 + Math.random() * 50, Math.random() * 1000 - 500);
        cloudGroup.add(cloud);
    }
    scene.add(cloudGroup);
}

        // Função para criar a pista de pouso
        function createRunway() {
            const runwayGroup = new THREE.Group();
            runwayGroup.position.x = -40; // Mover a pista 40 unidades para a esquerda

            // Pista principal
            const runwayGeometry = new THREE.PlaneGeometry(10, 200); // Pista mais longa
            const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 });
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.rotation.x = -Math.PI / 2;
            runway.position.y = -3.96; // Ajustado para ficar no nível do terreno
            runway.receiveShadow = true;
            runwayGroup.add(runway);

            // Marcações centrais
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 0.2, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: -2 });
            for (let i = -90; i <= 90; i += 20) {
                const lineGeometry = new THREE.PlaneGeometry(0.5, 10);
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(0, -3.97, i); // Ajustado para ficar acima da pista
                runwayGroup.add(line);
            }

            // Linhas laterais
            const sideLineGeometry = new THREE.PlaneGeometry(0.2, 200);
            const leftLine = new THREE.Mesh(sideLineGeometry, lineMaterial);
            leftLine.rotation.x = -Math.PI / 2;
            leftLine.position.set(-4.5, -3.97, 0); // Ajustado para ficar acima da pista
            runwayGroup.add(leftLine);

            const rightLine = new THREE.Mesh(sideLineGeometry, lineMaterial);
            rightLine.rotation.x = -Math.PI / 2;
            rightLine.position.set(4.5, -3.97, 0); // Ajustado para ficar acima da pista
            runwayGroup.add(rightLine);

            return runwayGroup;
        }

        // Função para criar árvores instanciadas
        function createTrees() {
            const treeCount = 500; // Número de árvores
            const treeGroup = new THREE.Group();

            // Geometria do tronco
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 5);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4A2E0F });
            const instancedTrunks = new THREE.InstancedMesh(trunkGeometry, trunkMaterial, treeCount);
            instancedTrunks.castShadow = true;
            instancedTrunks.receiveShadow = true;

            // Geometria da copa (cone)
            const crownGeometry = new THREE.ConeGeometry(1, 2, 6);
            const crownMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const instancedCrowns = new THREE.InstancedMesh(crownGeometry, crownMaterial, treeCount);
            instancedCrowns.castShadow = true;
            instancedCrowns.receiveShadow = true;

            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const rotation = new THREE.Euler();
            const scale = new THREE.Vector3();

            for (let i = 0; i < treeCount; i++) {
                const randomScale = 0.5 + Math.random() * 0.5; // Revertendo para escala aleatória
                const posX = (Math.random() * 900 - 450); // Espalhar por uma área maior
                const posZ = (Math.random() * 900 - 450);

                // Evitar a área da pista (com uma pequena margem) na nova posição
                if (Math.abs(posX + 40) < 6 && Math.abs(posZ) < 105) {
                    continue;
                }

                const trunkY = -4 + randomScale; // Ajustando a posição Y do tronco para o chão
                const crownY = -4 + (randomScale * 3);

    

                position.set(posX, trunkY, posZ); // Ajustando a posição Y do tronco para o chão
                rotation.set(0, Math.random() * Math.PI * 2, 0);
                scale.set(randomScale, randomScale, randomScale);

                matrix.compose(position, new THREE.Quaternion().setFromEuler(rotation), scale);

                instancedTrunks.setMatrixAt(i, matrix);

                position.set(posX, crownY, posZ); // Copa acima do tronco
                matrix.compose(position, new THREE.Quaternion().setFromEuler(rotation), scale);
                instancedCrowns.setMatrixAt(i, matrix);
            }

            instancedTrunks.instanceMatrix.needsUpdate = true;
            instancedCrowns.instanceMatrix.needsUpdate = true;

            scene.add(instancedTrunks);
            scene.add(instancedCrowns);
        }

        createTerrain();

        const loader = new GLTFLoader();
        loader.load('spitfire.glb', (gltf) => {
            airplane = gltf.scene;
            airplane.scale.set(1, 1, 1); // Ajuste se necessário
            // Posicionar o modelo para que o cockpit fique centrado na câmera (ajuste baseado no modelo)
            airplane.position.set(0, 200, 750); // Posição inicial do avião no mundo, ajustada para 5 unidades acima do terreno
            scene.add(airplane);
            // airplane.rotation.y = Math.PI; // Removido: Gira o avião 180 graus para que a frente fique para longe da câmera
            airplane.add(camera); // Adicionado: Câmera como filho do avião
            window.airplane = airplane; // Tornar o objeto airplane globalmente acessível para depuração

            // Criar ícone 2D do avião para o minimapa (triângulo vermelho)
            const triangleShape = new THREE.Shape();
            triangleShape.moveTo(0, 10);
            triangleShape.lineTo(-5, -5);
            triangleShape.lineTo(5, -5);
            triangleShape.lineTo(0, 10);

            const triangleGeometry = new THREE.ShapeGeometry(triangleShape);
            const triangleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, depthTest: false });
            minimapAirplane = new THREE.Mesh(triangleGeometry, triangleMaterial);
            minimapAirplane.name = 'airplane_clone';
            minimapAirplane.scale.set(3, 3, 3);
            minimapAirplane.rotation.x = -Math.PI / 2; // Deitado no plano XZ
            minimapAirplane.position.y = -3.4; // Acima da pista para evitar z-fighting, alinhado com o chão da cena principal
            minimapAirplane.renderOrder = 999; // Renderizar por cima
            minimapScene.add(minimapAirplane);
            // Não usar o triângulo 3D; manter apenas o ponteiro HTML fixo
            minimapAirplane.visible = false;

            // Encontrar a hélice no modelo carregado
            let propellerToRemove = null;
            airplane.traverse((child) => {
                if (child.type === 'Bone' && child.name === 'prop_02') {
                    propellerToRemove = child;
                }
            });

            if (propellerToRemove && propellerToRemove.parent) {
                propellerToRemove.parent.remove(propellerToRemove);
    
            }
            
            // Carregar protótipo e instanciar 5 aviões inimigos de cantos do terreno via pool
            ensureEnemyPrototype().then(() => {
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                // Definir três inimigos como perseguidores do jogador
                const pursuers = enemyAirplanes.slice(0, 3);
                pursuers.forEach((e) => {
                    if (!e || !e.userData) return;
                    e.userData.role = 'pursuit';
                    e.userData.turnRate = (e.userData.turnRate || 0.6) * 1.4; // virar mais rápido
                    e.userData.maxBank = Math.max(e.userData.maxBank || 0.5, 0.8); // inclinar mais
                    e.userData.maxClimbRate = Math.max(e.userData.maxClimbRate || 20, 35); // subir/mergulhar mais
                    e.userData.bankLerp = Math.max(e.userData.bankLerp || 0.05, 0.12);
                    e.userData.maxPitch = 0.7; // nariz mais agressivo
                });
            }).catch(error => {
                console.error('Erro ao inicializar inimigos:', error);
            });

            // Configurar a câmera para seguir o avião (não mais necessário, pois é filho)
            // setupCamera();
        }, undefined, (error) => {
            console.error(error);
        });

        // Controles básicos
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        const hud = document.getElementById('hud');
        // Estrutura do HUD: direção em números e barras para velocidade/altitude/combustível
        hud.innerHTML = `
            <div class="hud-heading">Direção: <span id="hud-heading-value">0°</span></div>
            <div class="hud-item">
                <div class="hud-label">Velocidade</div>
                <div class="hud-value"><span id="hud-speed-value">0</span> km/h</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Altitude</div>
                <div class="hud-value"><span id="hud-altitude-value">0</span> m</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Combustível</div>
                <div class="hud-bar"><div id="hud-fuel-fill" class="hud-fill"></div></div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Vida</div>
                <div class="hud-bar"><div id="hud-health-fill" class="hud-fill"></div></div>
            </div>
        `;
        const hudHeadingValue = document.getElementById('hud-heading-value');
        const hudSpeedValue = document.getElementById('hud-speed-value');
            const hudAltitudeValue = document.getElementById('hud-altitude-value');
        const hudFuelFill = document.getElementById('hud-fuel-fill');
        const hudHealthFill = document.getElementById('hud-health-fill');

        // --- Modal e gerenciamento de fases ---
        const levelModal = document.getElementById('level-modal');
        const startNextBtn = document.getElementById('start-next-level');
        let currentLevel = 1;
        let awaitingNextLevel = false;

        function showLevelModal() {
            if (levelModal) levelModal.style.display = 'flex';
        }
        function hideLevelModal() {
            if (levelModal) levelModal.style.display = 'none';
        }
        function startNextLevel() {
            currentLevel++;
            hideLevelModal();
            awaitingNextLevel = false;
            ensureEnemyPrototype().then(() => {
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                spawnEnemyAt(randomCornerSpawn());
                const pursuers = enemyAirplanes.slice(0, 3);
                pursuers.forEach((e) => {
                    if (!e || !e.userData) return;
                    e.userData.role = 'pursuit';
                    e.userData.turnRate = (e.userData.turnRate || 0.6) * 1.4;
                    e.userData.maxBank = Math.max(e.userData.maxBank || 0.5, 0.8);
                    e.userData.bankLerp = Math.max(e.userData.bankLerp || 0.05, 0.12);
                    e.userData.maxPitch = 0.7;
                });
            }).catch(err => console.error('Erro ao iniciar próxima fase:', err));
        }
        if (startNextBtn) startNextBtn.addEventListener('click', startNextLevel);

        // Variáveis para suavização (estas serão substituídas pela lógica do planeState)
        // const clock = new THREE.Clock(); // Já existe
        // let currentPitch = 0;
        // let currentYaw = 0;
        // let currentRoll = 0;
        // let currentSpeed = 0;
        // const maxRate = 0.02;
        // const smoothing = 0.08;
        // const baseSpeed = 0.2;
        // let swayTime = 0;

        // Quaternions para rotação local (ainda podem ser úteis, mas a lógica será diferente)
        // const qPitch = new THREE.Quaternion();
        // const qYaw = new THREE.Quaternion();
        // const qRoll = new THREE.Quaternion();

        // --- Início da nova lógica baseada em simulador trae.txt ---
        const clock = new THREE.Clock();
        let airplane;
        let propeller = null; // Variável para armazenar a hélice
        let propellerSpeed = 0.5; // Velocidade inicial da hélice
        const cameraOffset = new THREE.Vector3(0, 0.8, -2); // Offset da câmera em relação ao avião ajustado para primeira pessoa

        // Array para armazenar os aviões inimigos (movido para escopo global)
        const enemyAirplanes = [];
        // Limites do terreno para manter inimigos dentro da área
        const enemyBounds = { minX: -900, maxX: 900, minZ: -900, maxZ: 900, minY: 150, maxY: 200 };
        const enemyCenter = new THREE.Vector3(0, 110, 0);
        const enemyMargin = 80; // margem para geração de waypoints longe das bordas

        function normalizeAngle(a) {
            return Math.atan2(Math.sin(a), Math.cos(a));
        }

        function randomWaypointWithinBounds() {
            const x = THREE.MathUtils.randFloat(enemyBounds.minX + enemyMargin, enemyBounds.maxX - enemyMargin);
            const z = THREE.MathUtils.randFloat(enemyBounds.minZ + enemyMargin, enemyBounds.maxZ - enemyMargin);
            const y = THREE.MathUtils.randFloat(enemyBounds.minY, enemyBounds.maxY);
            return new THREE.Vector3(x, y, z);
        }

        function randomCornerSpawn() {
            const corners = [
                new THREE.Vector3(enemyBounds.minX, 200, enemyBounds.minZ),
                new THREE.Vector3(enemyBounds.minX, 200, enemyBounds.maxZ),
                new THREE.Vector3(enemyBounds.maxX, 200, enemyBounds.minZ),
                new THREE.Vector3(enemyBounds.maxX, 200, enemyBounds.maxZ),
            ];
            return corners[Math.floor(Math.random() * corners.length)].clone();
        }

        // Protótipo único de inimigo e helpers para inicialização via pool
        let enemyPrototype = null;
        let enemyPrototypePromise = null;
        function ensureEnemyPrototype() {
            if (enemyPrototype) return Promise.resolve(enemyPrototype);
            if (!enemyPrototypePromise) {
                enemyPrototypePromise = new Promise((resolve) => {
                    loader.load('spitfire_enemy.glb', (gltf) => {
                        enemyPrototype = gltf.scene;
                        resolve(enemyPrototype);
                    });
                });
            }
            return enemyPrototypePromise;
        }

        // Geometria e Material para os projéteis
        const bulletGeometry = new THREE.SphereGeometry(0.2, 12, 12); // maior para fácil visualização
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Vermelho para visibilidade (jogador)

        const bullets = []; // Array para armazenar os projéteis ativos do jogador

        // Projéteis dos inimigos (cor diferente para distinguir)
        const enemyBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Amarelo para inimigos
        const enemyBullets = []; // Array de projéteis dos inimigos

        // --- Infraestrutura de Pool de Objetos ---
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 0) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.items = [];
                this.free = [];
                for (let i = 0; i < initialSize; i++) {
                    const obj = this.createFn();
                    this.items.push(obj);
                    this.free.push(obj);
                }
            }
            acquire() {
                if (this.free.length > 0) return this.free.pop();
                const obj = this.createFn();
                this.items.push(obj);
                return obj;
            }
            release(obj) {
                this.resetFn(obj);
                this.free.push(obj);
            }
        }

        const playerBulletPool = new ObjectPool(
            () => {
                const b = new THREE.Mesh(bulletGeometry, bulletMaterial);
                b.visible = false;
                b.userData = { velocity: new THREE.Vector3(), birth: 0, guided: false };
                return b;
            },
            (b) => {
                b.visible = false;
                if (b.parent) scene.remove(b); // Remover da cena quando liberado
                if (!b.userData) b.userData = {};
                if (!b.userData.velocity) b.userData.velocity = new THREE.Vector3();
                b.userData.velocity.set(0, 0, 0);
                b.userData.birth = 0;
                b.userData.guided = false;
            },
            60
        );

        const enemyBulletPool = new ObjectPool(
            () => {
                const b = new THREE.Mesh(bulletGeometry, enemyBulletMaterial);
                b.visible = false;
                b.userData = { velocity: new THREE.Vector3(), birth: 0 };
                return b;
            },
            (b) => {
                b.visible = false;
                if (!b.userData) b.userData = {};
                if (!b.userData.velocity) b.userData.velocity = new THREE.Vector3();
                b.userData.velocity.set(0, 0, 0);
                b.userData.birth = 0;
            },
            80
        );

        // Pool para aviões inimigos (clones do protótipo)
        const enemyAirplanePool = new ObjectPool(
            () => {
                if (!enemyPrototype) {
                    // Caso excepcional: se adquirir antes do carregamento, retornar um Group vazio
                    const g = new THREE.Group();
                    g.visible = false;
                    return g;
                }
                const clone = SkeletonUtils.clone(enemyPrototype);
                clone.scale.set(1, 1, 1);
                clone.rotation.order = 'YXZ';
                clone.visible = false;
                return clone;
            },
            (enemy) => {
                enemy.visible = false;
                // Resetar estado mínimo
                enemy.userData = enemy.userData || {};
                enemy.userData.dying = false;
                enemy.userData.waypoint = null;
                enemy.userData.verticalSpeed = 0;
                enemy.userData.spinSpeed = 0;
                if (enemy.userData.minimapMarker) {
                    minimapScene.remove(enemy.userData.minimapMarker);
                    enemy.userData.minimapMarker = null;
                }
            },
            0
        );

        // Função para spawn de inimigo usando o pool
        function spawnEnemyAt(position) {
            const enemyAirplane = enemyAirplanePool.acquire();
            enemyAirplane.visible = true;
            if (!enemyAirplane.parent) scene.add(enemyAirplane);
            enemyAirplane.position.copy(position);

            const initialWaypoint = enemyCenter.clone();
            const desiredYaw = Math.atan2(position.x - initialWaypoint.x, position.z - initialWaypoint.z);
            enemyAirplane.rotation.y = desiredYaw;

            enemyAirplane.userData = {
                speed: 40 + Math.random() * 30,
                turnRate: 0.6 + Math.random() * 0.7,
                nextChangeAt: performance.now() + 2000 + Math.random() * 3000,
                targetAltitude: position.y,
                verticalSpeed: 0,
                maxClimbRate: 28,
                waypoint: initialWaypoint,
                maxBank: 0.5 + Math.random() * 0.4,
                bankLerp: 0.08,
                maxPitch: 0.5,
                role: 'random',
                hp: THREE.MathUtils.randInt(5, 8),
                dying: false,
                spinSpeed: 0,
            };

            // Criar/reativar marcador do inimigo no minimapa
            const enemyMarkerGeom = new THREE.CircleGeometry(3, 16);
            const enemyMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const enemyMarker = new THREE.Mesh(enemyMarkerGeom, enemyMarkerMat);
            enemyMarker.rotation.x = -Math.PI / 2;
            enemyMarker.position.y = -3.96;
            minimapScene.add(enemyMarker);
            enemyAirplane.userData.minimapMarker = enemyMarker;

            enemyAirplanes.push(enemyAirplane);
            return enemyAirplane;
        }

        // Efeitos visuais: explosões e fumaça
        const explosions = [];
        const smokePuffs = [];

        

        // Texture helper para flash de explosão (sprite radial leve)
        let explosionSpriteTexture = null;
        function getExplosionSpriteTexture() {
            if (explosionSpriteTexture) return explosionSpriteTexture;
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, 'rgba(255,255,200,1)');
            grd.addColorStop(0.4, 'rgba(255,180,60,0.9)');
            grd.addColorStop(0.8, 'rgba(180,60,10,0.4)');
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            explosionSpriteTexture = new THREE.CanvasTexture(canvas);
            explosionSpriteTexture.needsUpdate = true;
            return explosionSpriteTexture;
        }

        // Flash curto para impactos no jogador (sprite additive, duração breve)
        function createHitFlash(position, scale = 1) {
            const mat = new THREE.SpriteMaterial({
                map: getExplosionSpriteTexture(),
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(position);
            sprite.scale.setScalar(1.8 * scale);
            sprite.userData = {
                birth: performance.now(),
                duration: 160,
                scaleBase: 1,
                scaleGrowth: 2.0,
                opacityStart: 1,
                opacityEnd: 0
            };
            scene.add(sprite);
            explosions.push(sprite);
        }
        // Clarão preso à câmera: aparece sempre na frente da visão
        function createCameraHitFlash(scale = 1) {
            const mat = new THREE.SpriteMaterial({
                map: getExplosionSpriteTexture(),
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(mat);
            // posição inicial em frente à câmera (será atualizada a cada frame)
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const offset = 1.6; // distância à frente da câmera
            sprite.position.copy(camera.position).add(dir.multiplyScalar(offset));
            sprite.scale.setScalar(3.2 * scale); // maior para visibilidade
            sprite.renderOrder = 9999;
            sprite.userData = {
                birth: performance.now(),
                duration: 220,
                scaleBase: 1,
                scaleGrowth: 3.2,
                opacityStart: 1,
                opacityEnd: 0,
                trackCamera: true,
                cameraOffset: offset
            };
            scene.add(sprite);
            explosions.push(sprite);
        }

        // Explosão no ar (impacto de bala) mais realista e leve
        // Aceita multiplicador de escala opcional
        function createExplosion(position, scale = 1) {
            const base = position.clone();
            base.y = Math.max(base.y, 1);
            const nowBirth = performance.now();

            // Flash inicial (sprite additive, duração curtíssima)
            const flashMat = new THREE.SpriteMaterial({
                map: getExplosionSpriteTexture(),
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const flash = new THREE.Sprite(flashMat);
            flash.position.copy(base);
            flash.scale.setScalar(2.8 * scale);
            flash.userData = {
                birth: nowBirth,
                duration: 220,
                scaleBase: 1,
                scaleGrowth: 2.8,
                opacityStart: 1,
                opacityEnd: 0
            };
            scene.add(flash);
            explosions.push(flash);

            // Puffs de fogo/fumaça (poucos meshes para manter leve)
            const puffCount = 6 + Math.floor(Math.random() * 3); // 6-8 puffs
            for (let i = 0; i < puffCount; i++) {
                const size = (0.3 + Math.random() * 0.4) * scale;
                const geo = new THREE.SphereGeometry(size * 1.2, 12, 12);
                const hue = 0.08 + Math.random() * 0.06; // tons alaranjados
                const color = new THREE.Color().setHSL(hue, 0.9, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const puff = new THREE.Mesh(geo, mat);
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 2.2 * scale,
                    (Math.random() - 0.5) * 1.6 * scale,
                    (Math.random() - 0.5) * 2.2 * scale
                );
                puff.position.copy(base).add(offset);
                puff.userData = {
                    birth: nowBirth,
                    duration: 100 + Math.random() * 400,
                    scaleBase: 0.8,
                    scaleGrowth: 3.2 + Math.random() * 1.4,
                    opacityStart: 1,
                    opacityEnd: 0
                };
                scene.add(puff);
                explosions.push(puff);
            }

            // Pequena onda de choque (anel) orientada aproximadamente para a câmera
            const ringGeo = new THREE.RingGeometry(0.25 * scale, 0.35 * scale, 24);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffe09a, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(base);
            // olhar para a câmera no momento do impacto (não atualiza depois, leve)
            ring.lookAt(camera.position);
            ring.userData = {
                birth: nowBirth,
                duration: 500,
                scaleBase: 1,
                scaleGrowth: 2.6,
                opacityStart: 0.9,
                opacityEnd: 0
            };
            scene.add(ring);
            explosions.push(ring);
        }

        // Explosão do jogador com duração de 1 segundo
        function createPlayerExplosion(position, scale = 1) {
            const base = position.clone();
            base.y = Math.max(base.y, 1);
            const nowBirth = performance.now();

            // Flash inicial mais longo
            const flashMat = new THREE.SpriteMaterial({
                map: getExplosionSpriteTexture(),
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const flash = new THREE.Sprite(flashMat);
            flash.position.copy(base);
            flash.scale.setScalar(3.2 * scale);
            flash.userData = {
                birth: nowBirth,
                duration: 1000,
                scaleBase: 1,
                scaleGrowth: 3.2,
                opacityStart: 1,
                opacityEnd: 0
            };
            scene.add(flash);
            explosions.push(flash);

            // Puffs de fogo/fumaça com duração estendida
            const puffCount = 8 + Math.floor(Math.random() * 4); // 8-11 puffs
            for (let i = 0; i < puffCount; i++) {
                const size = (0.5 + Math.random() * 0.6) * scale;
                const geo = new THREE.SphereGeometry(size * 1.2, 12, 12);
                const hue = 0.08 + Math.random() * 0.06;
                const color = new THREE.Color().setHSL(hue, 0.9, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const puff = new THREE.Mesh(geo, mat);
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 2.6 * scale,
                    (Math.random() - 0.5) * 1.8 * scale,
                    (Math.random() - 0.5) * 2.6 * scale
                );
                puff.position.copy(base).add(offset);
                puff.userData = {
                    birth: nowBirth,
                    duration: 1000 + Math.random() * 400,
                    scaleBase: 0.8,
                    scaleGrowth: 3.2 + Math.random() * 1.6,
                    opacityStart: 1,
                    opacityEnd: 0
                };
                scene.add(puff);
                explosions.push(puff);
            }

            // Onda de choque com 1 segundo
            const ringGeo = new THREE.RingGeometry(0.35 * scale, 0.5 * scale, 28);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffe09a, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(base);
            ring.lookAt(camera.position);
            ring.userData = {
                birth: nowBirth,
                duration: 1000,
                scaleBase: 1,
                scaleGrowth: 3.0,
                opacityStart: 0.9,
                opacityEnd: 0
            };
            scene.add(ring);
            explosions.push(ring);
        }

        // Explosão aprimorada no chão (múltiplos puffs + onda de choque)
        function createGroundExplosion(position) {
            const base = position.clone();
            const groundY = getGroundHeightAt(base.x, base.z);
            base.y = groundY + 0.05;

            // múltiplos puffs com offsets
            for (let i = 0; i < 5; i++) {
                const size = 1.2 + Math.random() * 1.5;
                const geo = new THREE.SphereGeometry(size, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1 });
                const puff = new THREE.Mesh(geo, mat);
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 1.2,
                    (Math.random() - 0.5) * 3
                );
                puff.position.copy(base).add(offset);
                puff.userData = { birth: performance.now(), duration: 1200 };
                scene.add(puff);
                explosions.push(puff);
            }

            // onda de choque (anel) no plano do chão
            const ringGeo = new THREE.RingGeometry(0.6, 0.9, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffdd55, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(base);
            ring.userData = { birth: performance.now(), duration: 900 };
            scene.add(ring);
            explosions.push(ring);
        }

        // Fumaça contínua emitida pelo inimigo em queda
        function createSmokePuff(enemy) {
            const geo = new THREE.SphereGeometry(1, 12, 12);
            const mat = new THREE.MeshBasicMaterial({ color: '#3d3d3d', transparent: true, opacity: 0.8 });
            const puff = new THREE.Mesh(geo, mat);

            // Emitir um pouco acima e atrás do nariz
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(enemy.quaternion);
            const up = new THREE.Vector3(0, 1, 0);
            const emitOffset = forward.clone().multiplyScalar(-0.8).add(up.clone().multiplyScalar(0.3));
            puff.position.copy(enemy.position).add(emitOffset);

            puff.userData = { birth: performance.now(), duration: 2000 };
            scene.add(puff);
            smokePuffs.push(puff);
        }

        const planeState = {
            speed: -20, // Velocidade inicial
            altitude: 1000, // Altitude inicial
            fuel: 100, // Combustível inicial
            health: 15, // Vida inicial (tiros que pode levar)
            healthMax: 15, // Máximo de vida
            rotation: 0, // Rotação Y (yaw)
            pitch: 0, // Rotação X (pitch)
            roll: 0, // Rotação Z (roll)
            isTurningLeft: false,
            isTurningRight: false,
            isPitchingUp: false,
            isPitchingDown: false,
            isSpeedingUp: false,
            isSlowingDown: false,
            dead: false,
            deadAt: null,
            gameOverShown: false,
            wasGrounded: false,
        };

        // Variáveis para controle de câmera (OrbitControls não será usado, mas manteremos a estrutura para referência)
        const controls = {
            manualControl: false, // Indica se o controle manual da câmera está ativo
            target: new THREE.Vector3(), // O alvo da câmera (posição do avião)
            update: () => { /* No-op para esta implementação */ }
        };
        // --- Fim da nova lógica baseada em simulador trae.txt ---

        // --- Shake da câmera ---
        function triggerCameraShake(magnitude = 0.02, durationMs = 150) {
            const now = performance.now();
            camera.userData.shake = { start: now, end: now + durationMs, mag: magnitude, dur: durationMs };
        }

        // --- Funções de controle baseadas em simulador trae.txt ---
        const keyStates = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            c: false,    // Tecla C para diminuir velocidade
            x: false    // Tecla X para aumentar velocidade
        };

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                if (keyStates.hasOwnProperty(event.key)) {
                    keyStates[event.key] = true;
                    // updatePlaneStateFromKeys(); // Removed: State update now happens in animate loop
                }
            });

            document.addEventListener('keyup', (event) => {
                if (keyStates.hasOwnProperty(event.key)) {
                    keyStates[event.key] = false;
                    // updatePlaneStateFromKeys(); // Removed: State update now happens in animate loop
                }
            });
        }

        // Método para lidar com o pressionamento contínuo das teclas
        function updatePlaneStateFromKeys(delta) { // Added delta parameter
            planeState.isTurningLeft = keyStates.ArrowLeft;
            planeState.isTurningRight = keyStates.ArrowRight;
            planeState.isPitchingUp = keyStates.ArrowUp;
            planeState.isPitchingDown = keyStates.ArrowDown;
            planeState.isSpeedingUp = keyStates.x;
            planeState.isSlowingDown = keyStates.c;

            // Lógica de aumento/diminuição de velocidade (corrigida)
            const maxSpeed = -100; // Limite de velocidade máxima
            const minSpeed = 0;  // Limite de velocidade mínima
            const lerpFactorSpeed = 0.002; // Fator de interpolação para velocidade (ajustado para uma resposta mais suave)

            // Detecta se o avião está no solo usando a altura do terreno
            const groundY = getGroundHeightAt(airplane.position.x, airplane.position.z);
            const isGrounded = airplane.position.y <= groundY + 0.3;

            if (isGrounded) {
                // No solo: usar aceleração/frenagem gradual (em vez de LERP) para realismo
                const groundAccel = 18;   // aceleração no solo (unid/s²)
                const groundBrake = 440;   // frenagem no solo (unid/s²)
                const groundDrag = 40;     // arrasto quando sem throttle

                if (planeState.isSpeedingUp) {
                    // Acelerar: tornar speed mais negativo gradualmente até maxSpeed
                    planeState.speed = THREE.MathUtils.clamp(planeState.speed - groundAccel * delta, maxSpeed, minSpeed);
                } else if (planeState.isSlowingDown) {
                    // Frear: levar speed em direção a 0 gradualmente
                    planeState.speed = THREE.MathUtils.clamp(planeState.speed + groundBrake * delta, maxSpeed, minSpeed);
                } else {
                    // Sem throttle: aplicar leve arrasto no solo
                    planeState.speed = THREE.MathUtils.clamp(planeState.speed + groundDrag * delta, maxSpeed, minSpeed);
                }
            } else {
                // No ar: manter interpolação suave atual
                if (planeState.isSpeedingUp) {
                    planeState.speed = THREE.MathUtils.lerp(planeState.speed, maxSpeed, lerpFactorSpeed);
                } else if (planeState.isSlowingDown) {
                    planeState.speed = THREE.MathUtils.lerp(planeState.speed, minSpeed, lerpFactorSpeed);
                }
            }
        }
        // --- Fim das funções de controle ---

        // Disparo: dois tiros (um por asa) convergindo à frente do nariz
        function fireBullets() {
            if (!airplane) return;

            // Mira: ponto à frente do nariz do avião (usa eixo +Z local)
            const convergenceDistance = 200; // distância de convergência
            const forwardWorld = new THREE.Vector3(0, 0, -1).applyQuaternion(airplane.quaternion); // nariz do avião usa -Z
            const targetPoint = airplane.position.clone().add(forwardWorld.multiplyScalar(convergenceDistance));
            targetPoint.y += convergenceHeightOffset; // Aplica o offset vertical

            // Posições aproximadas das asas relativas ao centro do avião
            const wingSpread = 5;    // afastamento lateral
            const wingForward = 0.5;  // um pouco à frente (modelo usa -Z para frente)
            const wingHeight = -1.5;    // altura dos tiros (ajustado para levantar)

            const planePos = new THREE.Vector3();
            airplane.getWorldPosition(planePos);

            const leftOffset = new THREE.Vector3(-wingSpread, wingHeight, wingForward).applyQuaternion(airplane.quaternion);
            const rightOffset = new THREE.Vector3(wingSpread, wingHeight, wingForward).applyQuaternion(airplane.quaternion);

            const leftWorld = planePos.clone().add(leftOffset);
            const rightWorld = planePos.clone().add(rightOffset);

            const createBulletAt = (origin) => {
                const bullet = playerBulletPool.acquire();
                scene.add(bullet); // Sempre adicionar à cena
                bullet.visible = true;
                bullet.position.copy(origin);
                const dir = targetPoint.clone().sub(origin).normalize();
                const speed = 300;
                bullet.userData.velocity.copy(dir.multiplyScalar(speed));
                bullet.userData.birth = performance.now();
                bullet.userData.guided = false;
                bullets.push(bullet);
            };

            createBulletAt(leftWorld);
            createBulletAt(rightWorld);
        }

        // Cadência de tiro: manter disparos sincronizados ao segurar espaço
        let shooting = false;
        let lastShotTime = 0;
        const shotCooldownMs = 150; // taxa de disparo
        const convergenceHeightOffset = 34.0; // Ajuste vertical para o ponto de convergência

        document.addEventListener('keydown', (e) => {
            const isSpace = e.code === 'z' || e.key === ' ' || e.key === 'z';
            if (isSpace) {
                shooting = true;
                // Disparo imediato ao pressionar
                const nowShoot = performance.now();
                if (nowShoot - lastShotTime > shotCooldownMs) {
                    fireBullets();
                    lastShotTime = nowShoot;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            const isSpace = e.code === 'z' || e.key === ' ' || e.key === 'z';
            if (isSpace) shooting = false;
        });

        function animate() {
            requestAnimationFrame(animate);

            if (!airplane) return; // Adicionado: Garante que o avião esteja carregado

            // Rotacionar a hélice, se encontrada
            // Rotacionar a hélice, se encontrada
            if (propeller) {
                propeller.rotation.y += propellerSpeed;

                // Lógica para parar a hélice gradualmente
                if (Math.abs(planeState.speed) < 0.1) { // Verifica se a velocidade é aproximadamente zero
                    propellerSpeed = THREE.MathUtils.lerp(propellerSpeed, 0, 0.05); // Diminui gradualmente
                } else {
                    propellerSpeed = THREE.MathUtils.lerp(propellerSpeed, 0.5, 0.05); // Acelera gradualmente de volta
                }
            }

            const delta = clock.getDelta();
            updatePlaneStateFromKeys(delta); // Chamada para atualizar o estado do avião com base nas teclas
            const nowTime = performance.now();

            // (Caminhões removidos)

            // Atualizar a posição e rotação dos aviões inimigos com voo aleatório dentro dos limites
            const enemiesToRemove = [];

            enemyAirplanes.forEach(enemy => {
                const ud = enemy.userData || {};

                // Se estiver morrendo: anima queda em parafuso e remove ao tocar o chão
                if (ud.dying) {

                    // Garantir inicialização robusta mesmo se algum campo já vier setado pelo impacto
                    if (ud.dyingState === undefined) {
                        ud.dyingState = 'nosingDown';
                    }
                    if (ud.dyingStartPitch === undefined) {
                        ud.dyingStartPitch = enemy.rotation.x;
                    }
                    if (ud.dyingPitchProgress === undefined) {
                        ud.dyingPitchProgress = 0;
                    }
                    if (ud.verticalSpeed === undefined) {
                        ud.verticalSpeed = 0; // queda inicial
                    }
                    if (ud.horizontalSpeed === undefined) {
                        ud.horizontalSpeed = ud.speed || 40; // velocidade horizontal inicial
                    }
                    if (!ud.dyingDirection) {
                        ud.dyingDirection = new THREE.Vector3();
                        enemy.getWorldDirection(ud.dyingDirection);
                        ud.dyingDirection.multiplyScalar(-1);
                    }
                    if (ud.spinDelayTimer === undefined) {
                        ud.spinDelayTimer = 0;
                    }
                    // Inicializar rotação de corpo (roll) para simular perda de controle
                    if (ud.rollSpeed === undefined) {
                        ud.rollSpeed = (Math.random() - 0.5) * 4; // velocidade aleatória entre -2 e 2
                    }
                    if (ud.rollDirection === undefined) {
                        ud.rollDirection = Math.random() > 0.5 ? 1 : 1; // direção aleatória
                    }
                    if (ud.initialRoll === undefined) {
                        ud.initialRoll = enemy.rotation.z;
                    }
                    // Parâmetros de rotação progressiva e gravidade
                    if (ud.rollSpinRate === undefined) {
                        ud.rollSpinRate = 0; // taxa de spin inicial
                    }
                    if (ud.rollSpinAccel === undefined) {
                        ud.rollSpinAccel = 1.5; // aceleração de spin (rad/s^2)
                    }
                    if (ud.rollSpinMax === undefined) {
                        ud.rollSpinMax = 2.5; // taxa máxima de spin (rad/s)
                    }
                    if (ud.gravity === undefined) {
                        ud.gravity = enemy.userData?.gravity ?? 9.8; // gravidade aproximada
                    }

                    if (ud.dyingState === 'nosingDown') {
                        // Emissão de fumaça mais densa
                        ud.smokeTimer = (ud.smokeTimer || 0) + delta;
                        if (ud.smokeTimer > 0.06) { // Fumaça mais frequente
                            createSmokePuff(enemy);
                            // Criar fumaça adicional ocasionalmente
                            if (Math.random() < 0.3) {
                                setTimeout(() => createSmokePuff(enemy), 20);
                            }
                            ud.smokeTimer = 0;
                        }

                        // Nosing down
                        ud.dyingPitchProgress = Math.min(ud.dyingPitchProgress + delta * 0.3, 1);
                        const targetPitch = THREE.MathUtils.lerp(ud.dyingStartPitch, -5 * Math.PI / 18, ud.dyingPitchProgress);
                        enemy.rotation.x = targetPitch;

                        // Rotação de corpo (roll) com aceleração progressiva (integrada)
                        ud.rollSpinRate = Math.min(ud.rollSpinRate + ud.rollSpinAccel * delta, ud.rollSpinMax * 0.5);
                        enemy.rotation.z += ud.rollSpinRate * delta * ud.rollDirection;

                        // Manter velocidade horizontal quase constante
                        ud.horizontalSpeed = Math.max(ud.horizontalSpeed, 5);
                        enemy.position.x += ud.dyingDirection.x * ud.horizontalSpeed * delta;
                        enemy.position.z += ud.dyingDirection.z * ud.horizontalSpeed * delta;

                        // Queda vertical parabólica sob gravidade
                        ud.verticalSpeed -= (ud.gravity || 9.8) * delta;
                        enemy.position.y += ud.verticalSpeed * delta;

                        

                        // Check if nosing down is complete
                        if (ud.dyingPitchProgress >= 1) {
                            ud.dyingState = 'preSpinDelay';
                            ud.spinDelayTimer = 0; // Reset timer for delay
                        }
                    } else if (ud.dyingState === 'preSpinDelay') {
                        // Emissão de fumaça mais densa
                        ud.smokeTimer = (ud.smokeTimer || 0) + delta;
                        if (ud.smokeTimer > 0.06) { // Fumaça mais frequente
                            createSmokePuff(enemy);
                            // Criar fumaça adicional ocasionalmente
                            if (Math.random() < 0.4) {
                                setTimeout(() => createSmokePuff(enemy), 15);
                            }
                            ud.smokeTimer = 0;
                        }
                        
                        // Delay before spinning
                        ud.spinDelayTimer += delta;
                        
                        // Continuar rotação de corpo (roll) com aceleração progressiva
                        ud.rollSpinRate = Math.min((ud.rollSpinRate || 0) + (ud.rollSpinAccel || 1.5) * 1.2 * delta, (ud.rollSpinMax || 2.5));
                        enemy.rotation.z += ud.rollSpinRate * delta * (ud.rollDirection || 1);
                        
                        // Continue current trajectory and vertical speed
                        enemy.position.x += ud.dyingDirection.x * ud.horizontalSpeed * delta;
                        enemy.position.z += ud.dyingDirection.z * ud.horizontalSpeed * delta;
                        // Atualizar queda com gravidade consistente
                        ud.verticalSpeed -= (ud.gravity || 9.8) * delta;
                        enemy.position.y += ud.verticalSpeed * delta;

                        if (ud.spinDelayTimer >= 0.5) { // 0.5 seconds delay
                            ud.dyingState = 'spinning';
                        }
                    } else if (ud.dyingState === 'spinning') {
                        // Emissão de fumaça muito densa
                        ud.smokeTimer = (ud.smokeTimer || 0) + delta;
                        if (ud.smokeTimer > 0.05) { // Fumaça ainda mais frequente
                            createSmokePuff(enemy);
                            // Criar múltiplas fumaças para efeito mais dramático
                            if (Math.random() < 0.6) {
                                setTimeout(() => createSmokePuff(enemy), 10);
                                if (Math.random() < 0.3) {
                                    setTimeout(() => createSmokePuff(enemy), 25);
                                }
                            }
                            ud.smokeTimer = 0;
                        }

                        // Spinning leve no eixo Y (yaw) para manter realismo
                        enemy.rotation.y += (ud.spinSpeed || 0.2) * delta;
                        
                        // Rotação de corpo (roll) com taxa integrada e progressiva
                        ud.rollSpinRate = Math.min((ud.rollSpinRate || 0) + (ud.rollSpinAccel || 1.5) * 1.5 * delta, (ud.rollSpinMax || 2.5) * 1.1);
                        enemy.rotation.z += ud.rollSpinRate * delta * (ud.rollDirection || 1);

                        // Queda vertical com gravidade constante
                        ud.verticalSpeed -= (ud.gravity || 9.8) * delta;
                        enemy.position.y += ud.verticalSpeed * delta;

                        

                        // Continue moving in original direction, but with speed reducing gradually
                        ud.horizontalSpeed = Math.max(ud.horizontalSpeed , 5);
                        enemy.position.x += ud.dyingDirection.x * ud.horizontalSpeed * delta;
                        enemy.position.z += ud.dyingDirection.z * ud.horizontalSpeed * delta;
                    }

                    // Removido jitter de alta frequência durante a queda

                    // Atualizar marcador no minimapa
                    if (ud.minimapMarker) {
                        ud.minimapMarker.position.x = enemy.position.x;
                        ud.minimapMarker.position.z = enemy.position.z;
                    }

                    enemy.userData = ud;
                    // Remover apenas quando tocar o chão real sob o inimigo
                    const groundY = getGroundHeightAt(enemy.position.x, enemy.position.z);
                    if (enemy.position.y <= groundY + 0.2) {
                        createGroundExplosion(enemy.position);
                        if (ud.minimapMarker) minimapScene.remove(ud.minimapMarker);
                        enemiesToRemove.push(enemy);
                }
                return; // pular lógica de voo normal

                }
                // Papel do inimigo: voo pelo terreno com ataque por proximidade
                const playerPos = airplane.position.clone();
                let waypoint = ud.waypoint || randomWaypointWithinBounds();

                const distToWaypoint = enemy.position.distanceTo(waypoint);
                if (!ud.nextChangeAt || nowTime > ud.nextChangeAt || distToWaypoint < 60) {
                    ud.waypoint = randomWaypointWithinBounds();
                    ud.targetAltitude = ud.waypoint.y;
                    ud.nextChangeAt = nowTime + 2000 + Math.random() * 4000;
                }

                // Calcular yaw desejado e aplicar viragem limitada
                // Alinhar o eixo -Z do inimigo ao waypoint (modelo avança no -Z)
                const desiredYaw = Math.atan2(enemy.position.x - ud.waypoint.x, enemy.position.z - ud.waypoint.z);
                const yawError = normalizeAngle(desiredYaw - enemy.rotation.y);
                const maxYawStep = (ud.turnRate || 0.6) * delta;
                const yawStep = THREE.MathUtils.clamp(yawError, -maxYawStep, maxYawStep);
                // Aumentar raio de curva quando muito próximo do jogador
                const distCloseYaw = enemy.position.distanceTo(airplane.position);
                const minSepYaw = 240; // reduzir separação para curvar mais agressivo perto
                const yawScale = (ud.role === 'pursuit' && distCloseYaw < minSepYaw)
                    ? THREE.MathUtils.clamp(distCloseYaw / minSepYaw, 0.35, 1)
                    : 1;
                enemy.rotation.y += yawStep * yawScale;

                // Avançar para frente (velocidade em unidades/segundo)
                const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(enemy.quaternion);
                // Velocidade original (sem ajustes por pitch ou proximidade)
                const distToPlayerMove = enemy.position.distanceTo(airplane.position);
                const minSepMove = 180; // permitir aproximação maior
                enemy.position.addScaledVector(forwardVector, (ud.speed || ud.speed) * delta);

                // Repulsão suave quando muito próximo do jogador (evita colisões frontais)
                // if (ud.role === 'pursuit' && distToPlayerMove < minSepMove) {
                //     const toPlayer = playerPos.clone().sub(enemy.position);
                //     const away = toPlayer.clone().sub(enemy.position).normalize();
                //     const closeFactor = THREE.MathUtils.clamp((minSepMove - distToPlayerMove) / minSepMove, 0, 1);
                //     const avoidanceStrength = 120; // força base da repulsão
                //     enemy.position.addScaledVector(away, avoidanceStrength * closeFactor * delta);
                // }

                // Leve deriva aleatória apenas no voo normal, usando tempo em segundos
                const tSec = nowTime * 0.001;
                if (ud.role !== 'pursuit') {
                    enemy.position.x += Math.sin(tSec * 0.6) * 0.05;
                    enemy.position.z += Math.cos(tSec * 0.7) * 0.05;
                }

                // Ajustar altitude com velocidade vertical limitada (suavização realista)
                const targetAlt = THREE.MathUtils.clamp(ud.targetAltitude || enemyCenter.y, enemyBounds.minY, enemyBounds.maxY);
                const errorAlt = targetAlt - enemy.position.y;
                const desiredVel = THREE.MathUtils.clamp(errorAlt, -(ud.maxClimbRate || 20), (ud.maxClimbRate || 20));
                ud.verticalSpeed = THREE.MathUtils.lerp(ud.verticalSpeed || 0, desiredVel, 0.06);
                enemy.position.y += (ud.verticalSpeed || 0) * delta;
                enemy.position.y = THREE.MathUtils.clamp(enemy.position.y, enemyBounds.minY, enemyBounds.maxY);
                enemy.userData = ud;

                // Manter dentro dos limites do terreno (X/Z)
                enemy.position.x = THREE.MathUtils.clamp(enemy.position.x, enemyBounds.minX, enemyBounds.maxX);
                enemy.position.z = THREE.MathUtils.clamp(enemy.position.z, enemyBounds.minZ, enemyBounds.maxZ);

                // Inclinar (roll) proporcional à viragem — mais agressivo
                // Reduzir bank quando próximo para evitar curvas muito fechadas
                const bankScale = (ud.role === 'pursuit' && distCloseYaw < minSepYaw)
                    ? THREE.MathUtils.clamp(distCloseYaw / minSepYaw, 0.5, 1)
                    : 1;
                const targetBank = THREE.MathUtils.clamp(yawError * (1.8 * bankScale), -(ud.maxBank || 0.7), (ud.maxBank || 0.7));
                enemy.rotation.z = THREE.MathUtils.lerp(enemy.rotation.z || 0, targetBank, ud.bankLerp || 0.08);

                // Pitch agressivo: nariz para cima/baixo conforme erro de altitude e viragem
                const maxPitch = ud.maxPitch || 0.6;
                const pitchScale = (ud.role === 'pursuit' && distCloseYaw < minSepYaw)
                    ? THREE.MathUtils.clamp(distCloseYaw / minSepYaw, 0.6, 1)
                    : 1;
                const targetPitch = THREE.MathUtils.clamp((errorAlt * 0.008 + yawError * 0.06) * pitchScale, -maxPitch, maxPitch);
                enemy.rotation.x = THREE.MathUtils.lerp(enemy.rotation.x || 0, targetPitch, 0.06);

                // Evitar sair dos limites: se perto das bordas, escolher waypoint voltado ao centro
                const nearEdge = (
                    enemy.position.x < enemyBounds.minX + enemyMargin || enemy.position.x > enemyBounds.maxX - enemyMargin ||
                    enemy.position.z < enemyBounds.minZ + enemyMargin || enemy.position.z > enemyBounds.maxZ - enemyMargin
                );
                if (nearEdge) {
                    const safeWaypoint = randomWaypointWithinBounds();
                    ud.waypoint = safeWaypoint;
                    ud.targetAltitude = safeWaypoint.y;
                }

                // Disparo do inimigo: somente quando estiver em distância razoável e alinhado
                // Parâmetros de ataque (mais agressivos)
                ud.attackRange = ud.attackRange || 600; // engajar mais longe
                ud.fireAngle = ud.fireAngle || 0.5; // janela frontal mais ampla
                ud.fireCooldownMs = ud.fireCooldownMs || 200; // menor cooldown
                ud.nextFireAt = ud.nextFireAt || 0;

                const toPlayerVec = playerPos.clone().sub(enemy.position);
                const distToPlayerShoot = toPlayerVec.length();
                if (distToPlayerShoot < ud.attackRange) {
                    const enemyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(enemy.quaternion);
                    const aimAngle = enemyForward.angleTo(toPlayerVec.normalize());
                    if (aimAngle < ud.fireAngle && nowTime >= ud.nextFireAt) {
                        // Origem dos tiros (aproximação das asas do inimigo)
                        const wingSpread = 1.6; // reduzir espalhamento para convergir melhor
                        const wingForward = 1.6; // levemente mais à frente
                        const wingHeight = -0.4;

                        const leftOffset = new THREE.Vector3(-wingSpread, wingHeight, wingForward).applyQuaternion(enemy.quaternion);
                        const rightOffset = new THREE.Vector3(wingSpread, wingHeight, wingForward).applyQuaternion(enemy.quaternion);
                        const leftWorld = enemy.position.clone().add(leftOffset);
                        const rightWorld = enemy.position.clone().add(rightOffset);

                        // Mira com interceptação: estima posição futura do jogador
                        const speed = 360; // velocidade do projétil (unid/s)
                        const moveDir = new THREE.Vector3(0, 0, 1).applyQuaternion(airplane.quaternion); // direção de movimento do jogador
                        const playerSpeedApprox = Math.abs(planeState.speed) * 0.4; // ~unid/s (speed -100 ≈ 60 unid/s)
                        const playerVel = moveDir.multiplyScalar(playerSpeedApprox);
                        const timeToHit = Math.min(distToPlayerShoot / speed, 1.5);
                        const targetPoint = playerPos.clone().add(playerVel.clone().multiplyScalar(timeToHit));

                        const createEnemyBullet = (origin) => {
                            const b = enemyBulletPool.acquire();
                            b.visible = true;
                            if (!b.parent) scene.add(b);
                            b.position.copy(origin);
                            const dir = targetPoint.clone().sub(origin).normalize();
                            b.userData.velocity.copy(dir.multiplyScalar(speed));
                            b.userData.birth = performance.now();
                            enemyBullets.push(b);
                        };

                        createEnemyBullet(leftWorld);
                        createEnemyBullet(rightWorld);

                        // Próximo disparo após cooldown com jitter reduzido
                        ud.nextFireAt = nowTime + ud.fireCooldownMs + Math.random() * 40;
                    }
                }

                // Atualizar marcador no minimapa
                if (ud.minimapMarker) {
                    ud.minimapMarker.position.x = enemy.position.x;
                    ud.minimapMarker.position.z = enemy.position.z;
                }
            });
            // Remover (reciclar) inimigos que colidiram com o chão via pool
            if (enemiesToRemove.length) {
                enemiesToRemove.forEach(e => {
                    e.visible = false;
                    enemyAirplanePool.release(e);
                    const idx = enemyAirplanes.indexOf(e);
                    if (idx !== -1) enemyAirplanes.splice(idx, 1);
                });
            }


            // --- Lógica de atualização do avião baseada em simulador trae.txt ---
            if (!planeState.dead) {
                const turnSpeed = 0.012;
                const pitchSpeed = 0.008;
                const maxPitch = 0.8; // Maximum pitch angle
                const lerpFactorRotation = 0.02; // Fator de interpolação para rotação
                const lerpFactorPitch = 0.1;   // Fator de interpolação para inclinação
                const maxRoll = 1.4;
                const rollLerpFactor = 0.03;

                let targetRoll = 0;

                if (planeState.isTurningLeft) {
                    planeState.rotation += turnSpeed; // Invertido
                    targetRoll = maxRoll; // Invertido
                } else if (planeState.isTurningRight) {
                    planeState.rotation -= turnSpeed; // Invertido
                    targetRoll = -maxRoll; // Invertido
                }

                planeState.roll = THREE.MathUtils.lerp(planeState.roll, targetRoll, rollLerpFactor);

                if (planeState.isPitchingUp) {
                    planeState.pitch = Math.max(planeState.pitch - pitchSpeed, -maxPitch); // Invertido
                } else if (planeState.isPitchingDown) {
                    planeState.pitch = Math.min(planeState.pitch + pitchSpeed, maxPitch); // Invertido
                }

                // Consumo de combustível corrigido (usa velocidade absoluta)
                const speedAbs = Math.abs(planeState.speed);
                if (planeState.fuel > 0 && speedAbs > 2) {
                    planeState.fuel -= 0.005 * (speedAbs / 100);
                    planeState.fuel = Math.max(planeState.fuel, 0);
                } else if (planeState.fuel <= 0) {
                    // Sem combustível: reduzir velocidade em direção a 0 e baixar nariz
                    planeState.speed = Math.min(planeState.speed + 0.5, 0);
                    planeState.pitch = Math.max(planeState.pitch - 0.01, -0.2);
                }

                airplane.rotation.order = 'YXZ';
                airplane.rotation.y = THREE.MathUtils.lerp(airplane.rotation.y, planeState.rotation, lerpFactorRotation);

                // Se o avião estiver no chão, zera as rotações X e Z para evitar inclinação
                if (airplane.position.y <= -3.5) {
                    airplane.rotation.x = THREE.MathUtils.lerp(airplane.rotation.x, 0, lerpFactorPitch);
                    airplane.rotation.z = THREE.MathUtils.lerp(airplane.rotation.z, 0, rollLerpFactor);
                    // Permite subir do chão se a tecla 'down' for pressionada (para arremeter)
                    if (planeState.isPitchingDown) {
                        airplane.position.y += 0.01; // Reduzido para uma subida mais suave
                    }
                } else {
                    airplane.rotation.x = THREE.MathUtils.lerp(airplane.rotation.x, planeState.pitch, lerpFactorPitch);
                    airplane.rotation.z = THREE.MathUtils.lerp(airplane.rotation.z, planeState.roll, rollLerpFactor);
                }

                const moveDirection = new THREE.Vector3(0, 0, 1);
                moveDirection.applyQuaternion(airplane.quaternion);

                // A altitude no HUD deve sempre refletir a posição Y do avião com um offset
                planeState.altitude = airplane.position.y + 4.5;

                const moveVector = moveDirection.multiplyScalar(planeState.speed * 0.01);
                airplane.position.add(moveVector);

                // Condição de Stall: se a velocidade for muito baixa, o avião perde altitude
                if (planeState.speed >= -20) {
                    airplane.position.y -= 0.01; // Perde altitude
                }

                // Garante que o avião não passe do chão, a menos que esteja subindo
                if (!planeState.isPitchingDown || airplane.position.y > -4.5) {
                    airplane.position.y = Math.max(airplane.position.y, -3.5);
                }

                // Evento de pouso: ao tocar o chão, restaurar vida e combustível (apenas uma vez por toque)
                const groundY_player = getGroundHeightAt(airplane.position.x, airplane.position.z);
                const isGroundedRay = airplane.position.y <= groundY_player + 0.35;
                const isGroundedClamp = airplane.position.y <= -3.5 + 0.05;
                const isGroundedNow = isGroundedRay || isGroundedClamp;
                if (isGroundedNow && !planeState.wasGrounded) {
                    planeState.fuel = 100;
                    planeState.health = planeState.healthMax || 8;
                }
                planeState.wasGrounded = isGroundedNow;

                // Avanço de fase: pouso + nenhum inimigo ativo
                if (!planeState.dead && planeState.wasGrounded && enemyAirplanes.length === 0 && !awaitingNextLevel) {
                    awaitingNextLevel = true;
                    showLevelModal();
                }


                // Atualizar a câmera para seguir o avião (não mais necessário, pois é filho)
                // camera.position.copy(airplane.position).add(cameraOffset);
                // camera.lookAt(airplane.position);
            } else {
                // --- Sequência de queda do jogador (similar aos inimigos) ---
                if (planeState.dyingState === undefined) {
                    planeState.dyingState = 'nosingDown';
                }
                if (planeState.dyingStartPitch === undefined) {
                    planeState.dyingStartPitch = airplane.rotation.x;
                }
                if (planeState.dyingPitchProgress === undefined) {
                    planeState.dyingPitchProgress = 0;
                }
                if (planeState.verticalSpeed === undefined) {
                    planeState.verticalSpeed = 0;
                }
                if (planeState.horizontalSpeed === undefined) {
                    planeState.horizontalSpeed = Math.max(Math.abs(planeState.speed), 20);
                }
                if (planeState.dyingDirection === undefined) {
                    planeState.dyingDirection = new THREE.Vector3();
                    airplane.getWorldDirection(planeState.dyingDirection);
                    planeState.dyingDirection.multiplyScalar(-1);
                }

                // Emissão de fumaça durante a queda
                planeState.smokeTimer = (planeState.smokeTimer || 0) + delta;
                if (planeState.smokeTimer > 0.08) {
                    createSmokePuff(airplane);
                    planeState.smokeTimer = 0;
                }

                if (planeState.dyingState === 'nosingDown') {
                    planeState.dyingPitchProgress += delta * 0.6;
                    const targetPitch = -0.7;
                    const t = THREE.MathUtils.clamp(planeState.dyingPitchProgress, 0, 1);
                    airplane.rotation.x = THREE.MathUtils.lerp(planeState.dyingStartPitch, targetPitch, t);
                    airplane.rotation.z += 0.25 * delta; // leve roll

                    airplane.position.x += planeState.dyingDirection.x * planeState.horizontalSpeed * delta;
                    airplane.position.z += planeState.dyingDirection.z * planeState.horizontalSpeed * delta;
                    planeState.verticalSpeed -= (9.8) * delta;
                    airplane.position.y += planeState.verticalSpeed * delta;

                    if (planeState.dyingPitchProgress >= 1) {
                        planeState.dyingState = 'preSpinDelay';
                        planeState.spinDelayTimer = 0;
                    }
                } else if (planeState.dyingState === 'preSpinDelay') {
                    planeState.spinDelayTimer += delta;
                    // aceleração de roll
                    planeState.rollSpinRate = Math.min((planeState.rollSpinRate || 0) + 1.5 * 1.2 * delta, 2.5);
                    airplane.rotation.z += planeState.rollSpinRate * delta;

                    airplane.position.x += planeState.dyingDirection.x * planeState.horizontalSpeed * delta;
                    airplane.position.z += planeState.dyingDirection.z * planeState.horizontalSpeed * delta;
                    planeState.verticalSpeed -= 9.8 * delta;
                    airplane.position.y += planeState.verticalSpeed * delta;

                    if (planeState.spinDelayTimer >= 0.5) {
                        planeState.dyingState = 'spinning';
                    }
                } else if (planeState.dyingState === 'spinning') {
                    // yaw leve
                    airplane.rotation.y += (planeState.spinSpeed || 0.2) * delta;
                    // continuar roll acelerado
                    planeState.rollSpinRate = Math.min((planeState.rollSpinRate || 0) + 1.5 * 1.5 * delta, 2.75);
                    airplane.rotation.z += planeState.rollSpinRate * delta;

                    planeState.verticalSpeed -= 9.8 * delta;
                    airplane.position.y += planeState.verticalSpeed * delta;
                    airplane.position.x += planeState.dyingDirection.x * planeState.horizontalSpeed * delta;
                    airplane.position.z += planeState.dyingDirection.z * planeState.horizontalSpeed * delta;
                }

                // Parar hélice rapidamente ao morrer
                if (typeof propellerSpeed !== 'undefined') {
                    propellerSpeed = THREE.MathUtils.lerp(propellerSpeed, 0, 0.2);
                }

                // Colisão com o chão: explosão e parar
                const groundY = getGroundHeightAt(airplane.position.x, airplane.position.z);
                // Explode apenas uma vez, quando cruzar o limite do chão
                if (airplane.position.y <= groundY + 0.2 && planeState.dyingState !== 'crashed') {
                    createGroundExplosion(airplane.position);
                    airplane.position.y = groundY + 0.0;
                    planeState.verticalSpeed = 0;
                    planeState.horizontalSpeed = 0;
                    planeState.speed = 0;
                    planeState.altitude = 0;
                    planeState.dyingState = 'crashed';
                }
            }

            // Disparo contínuo com cooldown
            const nowShoot = performance.now();
            if (shooting && nowShoot - lastShotTime > shotCooldownMs) {
                fireBullets();
                lastShotTime = nowShoot;
            }

            // Atualizar projéteis (movimento e limpeza por tempo de vida)
            const now = performance.now();
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                // Movimento baseado em velocidade (unidades/segundo)
                const vel = b.userData.velocity;

                // Movimento simples: manter velocidade e direção definidas no disparo

                b.position.addScaledVector(vel, delta);
                let bulletRemoved = false; // Flag para indicar se o projétil foi removido por colisão

                // Checar colisão com inimigos
                for (let j = 0; j < enemyAirplanes.length; j++) {
                    const enemy = enemyAirplanes[j];
                    if (!enemy || !enemy.userData || enemy.userData.dying) continue;
                    const bulletWorldPos = new THREE.Vector3();
                    b.getWorldPosition(bulletWorldPos);
                    const enemyWorldPos = new THREE.Vector3();
                    enemy.getWorldPosition(enemyWorldPos);
                    const dist = bulletWorldPos.distanceTo(enemyWorldPos);
                    if (dist < 3) {
                        // Acertou: explosão e dano
                        createExplosion(enemy.position); // impacto padrão

                        enemy.userData.hp -= 1;
                        if (enemy.userData.hp <= 0) {
                            enemy.userData.dying = true;
                            enemy.userData.dyingState = 'nosingDown'; // Initialize dying state
                            enemy.userData.spinSpeed = 0.15 + Math.random() * 0.25; // yaw leve para realismo
                            enemy.userData.verticalSpeed = 0; // inicia queda sem velocidade vertical inicial
                            enemy.userData.gravity = 9.8; // aceleração gravitacional aproximada
                            enemy.userData.horizontalSpeed = enemy.userData.speed; // manter velocidade horizontal existente
                            enemy.userData.dyingDirection = new THREE.Vector3();
                            enemy.getWorldDirection(enemy.userData.dyingDirection);
                            enemy.userData.dyingDirection.multiplyScalar(-1);
                            // limpar alvo para não navegar mais
                            enemy.userData.waypoint = null;

                            // Explosão um pouco maior no tiro fatal (mesmo efeito, escalado)
                            createExplosion(enemy.position, 2.4);
                        }
                        // reciclar projétil
                        scene.remove(b); // Remover explicitamente da cena
                        b.visible = false; // Garantir que o projétil não seja visível
                        playerBulletPool.release(b);
                        bullets.splice(i, 1);
                        // console.log(`Bullet removed after enemy collision. Index: ${i}`);
                        bulletRemoved = true; // Define a flag
                        break; // Sai do loop interno (inimigos)
                    }
                }

                if (bulletRemoved) {
                    continue; // Pula para o próximo projétil no loop externo
                }

                // Remover após 5 segundos
                if (now - b.userData.birth > 5000) {
                    scene.remove(b);
                    b.visible = false;
                    playerBulletPool.release(b);
                    bullets.splice(i, 1);
                    // console.log(`Bullet removed by lifespan. Index: ${i}`);
                }
            }

            // Atualizar projéteis dos inimigos: movimento e colisão com o jogador
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eb = enemyBullets[i];
                const vel = eb.userData.velocity;
                eb.position.addScaledVector(vel, delta);

                // Colisão com o jogador
                const distPlayer = eb.position.distanceTo(airplane.position);
                if (distPlayer < 4.2) {
                    // Impacto visual no jogador: flash no lado atingido
                    const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(airplane.quaternion);
                    const toBullet = eb.position.clone().sub(airplane.position);
                    const sideSign = Math.sign(rightVec.dot(toBullet));
                    const sideOffset = rightVec.clone().multiplyScalar(2.0 * (sideSign >= 0 ? 1 : -1));
                    const hitPos = airplane.position.clone().add(sideOffset).add(new THREE.Vector3(0, 0.4, 0));
                    // Substituir clarão lateral por clarão em frente à câmera
                    createCameraHitFlash(1);
                    // Tranco na câmera no impacto
                    triggerCameraShake(0.02, 150);
                    planeState.health = Math.max(planeState.health - 1, 0);
                    // Efeito de morte simples ao zerar vida
                    if (planeState.health === 0 && !planeState.dead) {
                        planeState.dead = true;
                        planeState.deadAt = performance.now();
                        createPlayerExplosion(airplane.position, 3.0);
                    }
                    eb.visible = false;
                    enemyBulletPool.release(eb);
                    enemyBullets.splice(i, 1);
                    continue;
                }

                // Tempo de vida
                if (now - eb.userData.birth > 4500) {
                    eb.visible = false;
                    enemyBulletPool.release(eb);
                    enemyBullets.splice(i, 1);
                }
            }

            // Atualizar HUD: direção (números) e barras de progresso
            let heading = (airplane.rotation.y * 180 / Math.PI) % 360;
            if (heading < 0) heading += 360;
            hudHeadingValue.textContent = `${heading.toFixed(0)}°`;

            // Velocidade: normalizar de 0 (parado) a 1 (máximo) considerando speed em [-100..0]
            hudSpeedValue.textContent = `${(-planeState.speed * 10).toFixed(1)}`
            hudAltitudeValue.textContent = `${Math.round(planeState.altitude)}`;

            // Combustível: 0..100
            const fuelFraction = THREE.MathUtils.clamp(planeState.fuel / 100, 0, 1);
            hudFuelFill.style.width = `${(fuelFraction * 100).toFixed(0)}%`;

            // Vida: baseado em hits restantes (0..healthMax)
            const healthFraction = THREE.MathUtils.clamp(planeState.health / (planeState.healthMax || 8), 0, 1);
            if (hudHealthFill) {
                hudHealthFill.style.width = `${(healthFraction * 100).toFixed(0)}%`;
                // Cor dinâmica: verde alto, amarelo médio, vermelho baixo
                const color = healthFraction > 0.66 ? '#3cfb3c' : (healthFraction > 0.33 ? '#ffcc33' : '#ff3333');
                hudHealthFill.style.background = `linear-gradient(90deg, ${color}, ${color})`;
                hudHealthFill.style.boxShadow = `0 0 6px ${color}`;
            }

            // --- Atualizações do minimapa ---
            // Seguir o avião com a câmera do minimapa e girar o mapa pelo heading
            minimapCamera.position.set(airplane.position.x, 500, airplane.position.z);
            minimapCamera.lookAt(airplane.position.x, 0, airplane.position.z);
            // Rotacionar o mapa (câmera) no eixo Z usando o mesmo sinal do yaw do avião
            minimapCamera.rotation.z = airplane.rotation.y;

            // Atualizar o ícone 2D do avião
            if (minimapAirplane) {
                minimapAirplane.position.x = airplane.position.x;
                minimapAirplane.position.z = airplane.position.z;
                minimapAirplane.position.y = -3.4; // manter acima da pista, alinhado com o chão da cena principal
                // Triângulo fixo apontando para frente; mapa gira pelo heading
                minimapAirplane.rotation.x = -Math.PI / 2;
                minimapAirplane.rotation.y = Math.PI; // inverter para que a ponta seja a frente
                minimapAirplane.rotation.z = 0;
            }

            // Renderizar o minimapa
            minimapRenderer.render(minimapScene, minimapCamera);

            // Atualizar explosões (fade out e expansão) com parâmetros opcionais por item
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i];
                const age = now - ex.userData.birth;
                const t = age / ex.userData.duration;
                if (t >= 1) {
                    scene.remove(ex);
                    explosions.splice(i, 1);
                } else {
                    // Manter clarões presos à câmera em frente à visão
                    if (ex.userData && ex.userData.trackCamera) {
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        const offs = ex.userData.cameraOffset ?? 1.4;
                        ex.position.copy(camera.position).add(dir.multiplyScalar(offs));
                        if (ex.material) {
                            ex.material.depthTest = false;
                            ex.material.depthWrite = false;
                        }
                        ex.renderOrder = 9999;
                    }
                    const base = ex.userData.scaleBase ?? 1;
                    const growth = ex.userData.scaleGrowth ?? 3.5;
                    const scale = base + growth * t;
                    ex.scale.setScalar(scale);

                    const oStart = ex.userData.opacityStart ?? 1;
                    const oEnd = ex.userData.opacityEnd ?? 0;
                    const opacity = oStart + (oEnd - oStart) * t;
                    if (ex.material && 'opacity' in ex.material) {
                        ex.material.opacity = opacity;
                    }
                }
            }

            // Atualizar fumaça (cresce, sobe e desaparece)
            for (let i = smokePuffs.length - 1; i >= 0; i--) {
                const s = smokePuffs[i];
                const age = now - s.userData.birth;
                const t = age / s.userData.duration;
                if (t >= 1) {
                    scene.remove(s);
                    smokePuffs.splice(i, 1);
                } else {
                    const scale = 1 + 2.0 * t;
                    s.scale.setScalar(scale);
                    s.material.opacity = 0.8 * (1 - t);
                    s.position.y += 0.4 * (delta * 60) / 60; // sobe devagar
                    s.position.x += (Math.random() - 0.5) * 0.01;
                    s.position.z += (Math.random() - 0.5) * 0.01;
                }
            }

            // Game Over: exibir overlay após 1 segundo da morte
            if (planeState.dead && !planeState.gameOverShown) {
                const start = planeState.deadAt || now;
                const elapsed = now - start;
                if (!planeState.deadAt) planeState.deadAt = now;
                if (elapsed >= 1000) {
                    const go = document.getElementById('game-over');
                    if (go) go.style.display = 'flex';
                    planeState.gameOverShown = true;
                }
            }

            // Aplicar shake da câmera (local ao avião)
            if (camera.userData.shake) {
                const nowShake = now;
                const sh = camera.userData.shake;
                if (nowShake < sh.end) {
                    const t = (sh.end - nowShake) / sh.dur; // decaimento 1->0
                    // Offset aleatório pequeno em XYZ
                    const ox = (Math.random() - 0.5) * 2 * sh.mag * t;
                    const oy = (Math.random() - 0.5) * 2 * sh.mag * t;
                    const oz = (Math.random() - 0.5) * 2 * sh.mag * t;
                    camera.position.copy(camera.userData.basePosition).addScalar(0); // garantir base
                    camera.position.x += ox;
                    camera.position.y += oy;
                    camera.position.z += oz;
                    // Pequena vibração angular
                    camera.rotation.x = camera.userData.baseRotation.x + (Math.random() - 0.5) * 0.02 * t;
                    camera.rotation.y = camera.userData.baseRotation.y + (Math.random() - 0.5) * 0.02 * t;
                    camera.rotation.z = camera.userData.baseRotation.z + (Math.random() - 0.5) * 0.02 * t;
                } else {
                    // Restaurar base e encerrar shake
                    camera.position.copy(camera.userData.basePosition);
                    camera.rotation.copy(camera.userData.baseRotation);
                    camera.userData.shake = null;
                }
            }

            // Renderizar a cena principal
            renderer.render(scene, camera);
        }

        // Chamar setupControls uma vez para configurar os event listeners
        setupControls();

        // Iniciar a animação
        animate();

        function setupCamera() {
            camera.position.copy(airplane.position).add(cameraOffset);
            camera.lookAt(airplane.position);
        }

        // Iniciar simulação
        // const simulator = new LandingSimulator(); // Removido, pois estamos refatorando

        // Responsividade
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Ajustar tamanho do minimapa no resize
            minimapRenderer.setSize(minimapContainer.clientWidth, minimapContainer.clientHeight);
        });
    </script>
    <div id="crosshair"></div>
</body>
</html>